CVE-2024-26629 修复补丁: `edcf9725150e nfsd: fix RELEASE_LOCKOWNER`。

# 补丁信息

```
nfsd: 修复RELEASE_LOCKOWNER

在nfsd4_release_lockowner()中对so_count的测试是毫无意义且有害的。恢复使用check_for_locks()，并将其修改为不睡眠。

首先: 有害。
正如nfsd4_release_lockowner()的kdoc注释中所记录的，对so_count的测试可能会出现假阳性，导致返回NFS4ERR_LOCKS_HELD，而实际上并未持有任何锁。这显然是协议违规，在Linux NFS客户端中可能会导致不正确的行为。

如果在某个线程仍在处理由于给定所有者持有冲突锁而失败的LOCK请求时发送了RELEASE_LOCKOWNER，则处理该LOCK请求的nfsd线程可能会持有对锁所有者的引用（conflock），导致nfsd4_release_lockowner()返回错误的错误。

Linux NFS客户端会忽略NFS4ERR_LOCKS_HELD错误，因为它从不发送NFS4_RELEASE_LOCKOWNER而不首先释放任何锁，因此它知道这种错误是不可能的。它假设锁所有者实际上已被释放，因此可以自由地在稍后的锁请求中重用相同的锁所有者标识符。

当它确实重新使用了先前RELEASE失败的锁所有者标识符时，它将自然使用零的lock_seqid。然而，服务器，即使没有释放锁所有者，也会期望更大的lock_seqid，因此会用NFS4ERR_BAD_SEQID回应。

因此，允许假阳性是有害的。

这个测试毫无意义，因为...嗯...它没有任何意义。

so_count是三个不同计数的总和。
1/列在so_stateids上的状态集合
2/由这些状态拥有的任何活动vfs锁集合
3/各种瞬态计数，例如冲突锁。

当对'2'进行测试时，很明显其中一个是通过find_lockowner_str_locked()获得的瞬态引用。另一个预期是什么并不清楚。

实际上，计数通常为2，因为so_stateids上恰好有一个状态。如果有更多的话，这将失败。

在我的测试中，我看到了两种调用RELEASE_LOCKOWNER的情况。在一种情况下，CLOSE在RELEASE_LOCKOWNER之前被调用。这将导致所有锁状态被移除，因此锁所有者被丢弃（当没有更多引用时，通常会发生这种情况，这通常发生在锁状态被丢弃时）。当nfsd4_release_lockowner()发现锁所有者不存在时，它会返回成功。

另一种情况显示了一个'2'的so_count，并且在so_stateid中列出了一个状态。看起来Linux客户端为每个文件使用单独的锁所有者，从而导致每个锁所有者一个锁状态，因此对'2'的这个测试是安全的。对于另一个客户端，可能不安全。

因此，此补丁将check_for_locks()更改为使用（较新的）find_any_file_locked()，以便不对nfs4_file引用进行引用，因此永远不会调用nfsd_file_put()，也永远不会睡眠。有了这个检查，可以安全地恢复对check_for_locks()的使用，而不是针对神秘的'2'进行测试。
```

# 4.19合补丁

前置补丁`eb82dd393744 nfsd: convert fi_deleg_file and ls_file fields to nfsd_file`合入时有冲突。前置补丁`e0aa651068bf nfsd: don't call nfsd_file_put from client states seqfile display`合入时也有冲突。冲突太大合入风险大。